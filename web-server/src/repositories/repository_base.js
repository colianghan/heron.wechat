// Generated by LiveScript 1.2.0
(function(){
  var path, mongoose, file, logger, open, close, repository_base;
  path = require('path');
  mongoose = require('mongoose');
  file = require('../helpers/file');
  logger = require('../helpers/logger').getLogger('repository');
  open = function(mongo_config){
    var uri, options;
    uri = "mongodb://" + (mongo_config.username ? mongo_config.username + ":" + mongo_config.password + "@" : "") + mongo_config.host + ":" + mongo_config.port + "/" + mongo_config.database;
    options = {
      server: {
        "poolSize": mongo_config.poolsize
      }
    };
    return mongoose.createConnection(uri, options, function(){
      return logger.info("connected in " + uri);
    });
  };
  close = function(){
    return mongoose.disconnect(function(err){
      return logger.info("connection state: " + mongoose.STATES[mongoose.connection.readyState]);
    });
  };
  repository_base = (function(){
    repository_base.displayName = 'repository_base';
    var prototype = repository_base.prototype, constructor = repository_base;
    function repository_base(mongo_config){
      this.connection == null && (this.connection = open(mongo_config));
      this.connection.on("connecting", function(){
        return logger.info("connecting..");
      });
      this.connection.on("connected", function(){
        return logger.info("connected..");
      });
      this.connection.on("disconnecting", function(){
        return logger.info("disconnecting..");
      });
      this.connection.on("disconnected", function(){
        return logger.info("disconnected..");
      });
      this.connection.on("error", function(){
        this.connection.close();
        logger.info("connection state: " + mongoose.STATES[mongoose.connection.readyState]);
        return console.error.bind(console, "connect error: ");
      });
    }
    prototype.save = function(entity, next){
      return this.model.create(entity, next);
    };
    prototype.update = function(doc, update, next){
      return this.model.update(doc, update, next);
    };
    prototype.updateOne = function(id, update, next){
      return this.model.findOneAndUpdate(id, update, next);
    };
    prototype.remove = function(doc, next){
      return this.model.remove(doc, next);
    };
    prototype.removeOne = function(id, next){
      return this.model.findOneAndRemove(id, next);
    };
    prototype.findAll = function(next){
      return this.model.find(next);
    };
    prototype.findOne = function(doc, next){
      return this.model.findOne(doc, next);
    };
    prototype.findWithSort = function(doc, sort, next){
      return this.model.find(doc).sort(sort).exec(next);
    };
    prototype.count = function(doc, next){
      return this.model.count(doc, next);
    };
    prototype.findByPage = function(doc, sort, skip, limit, next){
      return this.model.find(doc).sort(sort).skip(skip).limit(limit).exec(next);
    };
    prototype.close = function(){
      return this.connection.close();
    };
    repository_base.close = function(){
      return close();
    };
    return repository_base;
  }());
  module.exports = repository_base;
}).call(this);
